<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>IPC-Android中的进程与进程间通信 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、Android中的进程官方解释Android的系统架构底层是Linux，上层采用的是可以运行java（其实是dex字节码）的虚拟机（Dalvik &amp;amp; ART），Dalvik的核心内容是实现库（libdvm.so），大体由C语言实现。依赖于Linux内核的一部分功能——线程机制、内存管理机制，能高效使用内存，并在低速CPU上表现出的高性能。每一个Android应用在底层都会对应一个独立的">
<meta name="keywords" content="Android,IPC,Binder">
<meta property="og:type" content="article">
<meta property="og:title" content="IPC-Android中的进程与进程间通信">
<meta property="og:url" content="http://febsky.me/2017/05/18/2017-05-18-IPC-Android中的进程与进程间通信/index.html">
<meta property="og:site_name" content="凉凉小线仔">
<meta property="og:description" content="一、Android中的进程官方解释Android的系统架构底层是Linux，上层采用的是可以运行java（其实是dex字节码）的虚拟机（Dalvik &amp;amp; ART），Dalvik的核心内容是实现库（libdvm.so），大体由C语言实现。依赖于Linux内核的一部分功能——线程机制、内存管理机制，能高效使用内存，并在低速CPU上表现出的高性能。每一个Android应用在底层都会对应一个独立的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/797798-de74ea7e350357e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-07-31T07:53:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IPC-Android中的进程与进程间通信">
<meta name="twitter:description" content="一、Android中的进程官方解释Android的系统架构底层是Linux，上层采用的是可以运行java（其实是dex字节码）的虚拟机（Dalvik &amp;amp; ART），Dalvik的核心内容是实现库（libdvm.so），大体由C语言实现。依赖于Linux内核的一部分功能——线程机制、内存管理机制，能高效使用内存，并在低速CPU上表现出的高性能。每一个Android应用在底层都会对应一个独立的">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/797798-de74ea7e350357e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternative" href="/atom.xml" title="凉凉小线仔" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-2017-05-18-IPC-Android中的进程与进程间通信" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      IPC-Android中的进程与进程间通信
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/05/18/2017-05-18-IPC-Android中的进程与进程间通信/" class="article-date">
  <time datetime="2017-05-18T06:46:31.000Z" itemprop="datePublished">2017-05-18</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a> <a class="article-category-link" href="/categories/Android/IPC/">IPC</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、Android中的进程"><a href="#一、Android中的进程" class="headerlink" title="一、Android中的进程"></a>一、Android中的进程</h1><p><a href="https://developer.android.com/guide/components/processes-and-threads.html" target="_blank" rel="noopener">官方解释</a><br>Android的系统架构底层是Linux，上层采用的是可以<del>运行java</del>（其实是dex字节码）的虚拟机（Dalvik &amp; ART），Dalvik的核心内容是实现库（libdvm.so），大体由C语言实现。依赖于Linux内核的一部分功能——线程机制、内存管理机制，能高效使用内存，并在低速CPU上表现出的高性能。每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。</p>
<h2 id="1-内核进程-确切的说是内核线程kernel-thread-和用户进程"><a href="#1-内核进程-确切的说是内核线程kernel-thread-和用户进程" class="headerlink" title="1. 内核进程(确切的说是内核线程kernel thread)和用户进程"></a>1. 内核进程(确切的说是内核线程kernel thread)和用户进程</h2><p>这个是根据进程运行空间来区分的。<a href="http://www.cnblogs.com/createyuan/p/3979142.html" target="_blank" rel="noopener">linux常见进程与内核线程</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/797798-de74ea7e350357e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-04 13.52.55.png"></p>
<p>上图是用ChromeADB这个工具抓取的系统进程信息，当然也可直接用adb 的ps命名查看。对上图表头的做些解释，<strong><code>PID指的是进程id</code>,<code>PPID指的是parent ID也就是父进程的pid</code></strong>。至于VSIZE和RSS是和内存相关的，暂时不管。仔细观察pid和ppid会发现规律。</p>
<p>1.0. <strong>进程</strong>这东西要从Linux说起，Android系统内核是Linux，所以Android系统启动，必须先要Linux系统启动。而Linux下有3个特殊的进程，<code>idle</code>进程(PID = 0), <code>init</code>进程(PID = 1)和<code>kthreadd</code>(PID = 2)，至于这三个进程的作用，可以简答的理解为<code>idle（PID=0）</code>的这个是操作系统boot起来后第一个线程，<code>init</code>和<code>kthreadd</code>都是由它通过<code>kernel_thread</code>创建出来的。<br>1.1. <strong>kthreadd线程</strong>由idle通过kernel_thread创建，并始终运行在内核空间，它的任务就是管理和调度其他内核线程kernel_thread（内核线程）。所有内核进程的用户都是root，所有的内核线程都是直接或者间接的以kthreadd为父进程 。<br>1.2. <strong>init进程:</strong>由idle通过kernel_thread创建，在Linux中的定义是一个由内核启动的用户级进程， Kerner启动后会调用<code>/system/core/init/Init.cpp</code>的main()方法，然后解析<code>/init.rc</code>文件，包括所有的<code>.rc</code>文件，最重要的Zygote进程启动起来。所以，init始终是第一个进程（其进程编号始终为1）。在系统启动完成完成后，init将变为守护进程监视系统其他进程。在Android中的含义也是一样的，是所有用户进程的父进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//主要进程的创建（kernel_thread或者fork）关系，PID给出的那几个的PID在任何设备上都是相同的</span><br><span class="line">idle(PID == 0)</span><br><span class="line">    |---init(PID==1)</span><br><span class="line">            |---servicemanager（它是整个Binder机制的守护进程）</span><br><span class="line">            |---zygote</span><br><span class="line">                 |---system_server</span><br><span class="line">                 |---com.xxx.app(每个app至少有一个进程)</span><br><span class="line">            |---mediaserver</span><br><span class="line">            |--- 。。。其他进程</span><br><span class="line">    |---kthreadd(PID == 2)</span><br><span class="line">            |---binder</span><br><span class="line">            |---watchdog</span><br><span class="line">            |---。。。其他进程</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实对于Android中进程，我们主要关心的是init进程fork出来的那几个重要的进程</p>
</blockquote>
<h2 id="2-进程生命周期"><a href="#2-进程生命周期" class="headerlink" title="2.进程生命周期"></a>2.进程生命周期</h2><p><a href="https://developer.android.com/guide/components/processes-and-threads.html" target="_blank" rel="noopener">看官网解释很清楚，不再抄过来了</a><br>Android进程的重要性，划分5级，前台进程的重要性最高，依次递减：<br>前台进程(Foreground process)<br>可见进程(Visible process)<br>服务进程(Service process)<br>后台进程(Background process)<br>空进程(Empty process)</p>
<p>作用：必要时（当资源有限时），系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。</p>
<h2 id="3-Android中开启进程的方式"><a href="#3-Android中开启进程的方式" class="headerlink" title="3. Android中开启进程的方式"></a>3. Android中开启进程的方式</h2><ul>
<li><p>Manifest文件给<code>&lt;activity&gt;</code> <code>&lt;service&gt;</code> <code>&lt;receiver&gt;</code> <code>&lt;provider&gt;</code>设置属性<code>android:process</code> 指定单独进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 假设包名为me.febsky.app --&gt;</span><br><span class="line"> &lt;activity</span><br><span class="line">       android:name=&quot;me.febsky.app.OtherActivity&quot;</span><br><span class="line">       android:process=&quot;:remote&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过jni在native层fork一个进程出来</p>
</li>
</ul>
<blockquote>
<p>注：<code>android:process=&quot;:remote&quot;</code> 这行代码翻译一下，其实他的完整进程名为：<code>me.febsky.app:remote</code>（假设当前应用包名为me.febsky.app）。进程名以“:”开头的进程属于当前应用的私有进程，其他应用不可以通过SharedUID的方式和他跑在同一个进程中；而如果没有用“:”，直接指定<code>android:process=&quot;me.febsky.remote&quot;</code> 说明开启的这个进程是可以和别的app（这个app必须和当前app签名相同并且指定了sharedUID）共享的。</p>
</blockquote>
<h1 id="二、Android中IPC"><a href="#二、Android中IPC" class="headerlink" title="二、Android中IPC"></a>二、Android中IPC</h1><p>一个app可以开启多个进程，那么多个进程间就有可能需要通信。IPC是Inter-Process Communication（进程间通信）的首字母缩小。</p>
<h2 id="1-Linux-中一些经典的IPC"><a href="#1-Linux-中一些经典的IPC" class="headerlink" title="1. Linux 中一些经典的IPC"></a>1. Linux 中一些经典的IPC</h2><p>Android系统是基于Linux内核的，而Linux内核继承和兼容了丰富的Unix系统进程间通信（IPC）机制。有传统的管道（Pipe）、信号（Signal）和跟踪（Trace），这三项通信手段只能用于父进程与子进程之间，或者兄弟进程之间；后来又增加了命令管道（Named Pipe），使得进程间通信不再局限于父子进程或者兄弟进程之间；为了更好地支持商业应用中的事务处理，在AT&amp;T的Unix系统V中，又增加了三种称为“System V IPC”的进程间通信机制，分别是报文队列（Message）、共享内存（Share Memory）和信号量（Semaphore）；后来BSD Unix对“System V IPC”机制进行了重要的扩充，提供了一种称为插口（Socket）的进程间通信机制</p>
<blockquote>
<p><strong>Socket</strong>:这个东西，在学java网络编程的时候接触的。它在Android中有个经典的使用场景，在启动一个单独进程中的Activity或者Service的时候（Activity和Service的启动后面再说，这里只需知道他们都是通过AMS启动的就行了），<code>ActivityManagerService</code>会通过Socket进程间通信机制，通知Zygote进程为这个应用程序创建一个新的进程。</p>
</blockquote>
<h2 id="2-Android上经典的IPC-Binder"><a href="#2-Android上经典的IPC-Binder" class="headerlink" title="2. Android上经典的IPC Binder"></a>2. Android上经典的IPC Binder</h2><h2 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h2><p>要说IPC，先要知道进程隔离的概念<br>wiki解释：进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>这个东西并不是Google搞出来的，Binder的前身是<a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="noopener">OpenBinder</a>，而OpenBinder的作者<a href="http://www.angryredplanet.com/~hackbod/" target="_blank" rel="noopener">Dianne Hackborn</a>现在在Google工作，负责Android平台的开发工作。</p>
<p>Binder主要由Client（Client进程）、Server（Server进程）、ServiceManager和Binder驱动程序组成。其中Client、Service和ServiceManager运行在用户空间，而Binder驱动程序运行在内核空间。核心组件就是 Binder驱动程序了，而ServiceManager提供辅助管理的功能，类似于DNS的作用，无论是Client还是Service进行通信前首先要和ServiceManager取得联系。而ServiceManager是一个守护进程，负责管理Server并向Client提供查询Server的功能。</p>
<p>这里面很重要的一点是Binder驱动，进程a与进程b通信实际上是进程a先于Binder驱动通信，然后Binder驱动再与进程b通信的一个过程。其实进程a或者进程b与Binder的通信也是进程间通信，不过这个Binder驱动是个特殊的进程，他运行在内核空间，至于Binder怎么就搞到了内核空间里面去了可以搜索（Linux的动态可加载内核模块（Loadable Kernel Module，LKM））。由于进程隔离的存在，进程a打死都不可能访问到进程b中的内存的，也就不能进行不能调用进程b中的方法，但是进程a可以通过<code>系统调用</code>的方式访问Binder进程（内核进程），而内核空间的进程能访问用户进程a或者进程b。<a href="http://blog.csdn.net/tommy_wxie/article/details/17122923/" target="_blank" rel="noopener">了解下Linux内核控件和用户控件的概念</a></p>
<p>ServiceManager是由init进程通过解析init.rc文件而创建的，其所对应的可执行程序/system/bin/servicemanager，所对应的源文件是service_manager.c，进程名为/system/bin/servicemanager。可以把<code>/init.rc</code>文件导出来看下，没什么神秘的，创建这个进程的指令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart drm</span><br></pre></td></tr></table></figure></p>

      

      
        
    </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/01/31/wankeguanjiabao/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          隐私权政策
        
      </div>
    </a>
  
  
    <a href="/2017/05/18/2017-05-18-Android Binder及其周边知识梳理 /" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android Binder及其周边知识梳理</div>
    </a>
  
</nav>

  
</article>



<section id="comment">
<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2017/05/18/2017-05-18-IPC-Android中的进程与进程间通信/" data-title="IPC-Android中的进程与进程间通信" data-url="http://febsky.me/2017/05/18/2017-05-18-IPC-Android中的进程与进程间通信/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:'febsky'};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->
</section>



</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/niyingxunzong/" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="javascript:void(0)"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2018 QX 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/Alex-fun/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/niyingxunzong/" class="mobile-nav-link">Github</a>
  
</nav>
    
<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>

<script src="/js/main.js"></script>
<script src="/js/script.js"></script>

  </div>
</body>
</html>